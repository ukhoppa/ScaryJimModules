--!strict
-- HauntedIslandModule.lua

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local hrp = Character:WaitForChild("HumanoidRootPart")

-- Module state
local loopActive = false
local collectingActive = false

-- Define collectible tiers
local TIERS = {
    GhostlyItem = {count = 0, items = {}, highlightColor = Color3.fromRGB(164,255,172)},
    RareArtifact = {count = 0, items = {}, highlightColor = Color3.fromRGB(255,200,50)},
}

-- Current target
local CurrentTarget = nil

-- Detect collectibles in Haunted Island
local function detectCollectibles()
    local island = Workspace:FindFirstChild("Islands") and Workspace.Islands:FindFirstChild("Haunted Island")
    if not island then return end

    for _, tier in pairs(TIERS) do
        tier.count = 0
        tier.items = {}
    end

    for _, model in ipairs(island:GetChildren()) do
        if model:IsA("Model") then
            -- Check for InteractionPart with correct color
            local part = model:FindFirstChild("InteractionPart")
            if part and part:IsA("BasePart") then
                if part.Color == Color3.fromRGB(164,255,172) then
                    local tier = TIERS.GhostlyItem
                    tier.count += 1
                    table.insert(tier.items, {model = model, parts = {part}})
                elseif part.Color == Color3.fromRGB(255,200,50) then
                    local tier = TIERS.RareArtifact
                    tier.count += 1
                    table.insert(tier.items, {model = model, parts = {part}})
                end
            end
        end
    end
end

-- Grab next target
local function grabNextTarget()
    for _, tierName in ipairs({"GhostlyItem","RareArtifact"}) do
        local tier = TIERS[tierName]
        if tier.count > 0 and #tier.items > 0 then
            local item = tier.items[1]
            item.tier = tierName
            return item
        end
    end
    return nil
end

-- Teleport and face function
local function tpAndFace(part)
    if not part then return end
    local direction = (hrp.Position - part.Position)
    if direction.Magnitude == 0 then direction = Vector3.new(0,3,-2) end
    local offset = direction.Unit * 5
    hrp.CFrame = CFrame.new(part.Position + offset, part.Position)
    workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    workspace.CurrentCamera.CFrame = CFrame.new(hrp.Position + Vector3.new(0,2,0), part.Position)
end

-- Main collection loop
task.spawn(function()
    while true do
        if loopActive then
            detectCollectibles()
            CurrentTarget = grabNextTarget()

            if CurrentTarget and CurrentTarget.model and CurrentTarget.model.Parent then
                local part = CurrentTarget.parts[1]
                if part then
                    tpAndFace(part)
                    task.wait(0.05)
                    -- Press E to collect
                    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                    task.wait(0.05)
                    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                end

                -- Wait until the current target is gone
                local elapsed = 0
                while CurrentTarget.model and CurrentTarget.model.Parent and loopActive do
                    task.wait(0.2)
                    elapsed += 0.2
                    if elapsed >= 150 then
                        break
                    end
                end
            end
        end
        task.wait(0.5)
    end
end)

-- Update tier counts loop
task.spawn(function()
    while true do
        -- Could integrate with Rayfield labels here
        task.wait(1)
    end
end)

-- Public API
local module = {}

module.Tiers = TIERS

module.GetCurrentTarget = function()
    return CurrentTarget
end

module.ToggleLoop = function(state)
    if state ~= nil then
        loopActive = state
    else
        loopActive = not loopActive
    end
    return loopActive
end

module.Refresh = detectCollectibles

return module
