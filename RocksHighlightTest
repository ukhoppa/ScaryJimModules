--// Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Camera = Workspace.CurrentCamera

--// Player references
local LocalPlayer = Players.LocalPlayer
local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

--// Island reference
local CurrentIsland = Instance.new("StringValue")
CurrentIsland.Name = "CurrentIsland"
CurrentIsland.Value = "Unknown"
CurrentIsland.Parent = LocalPlayer

--// Loop toggles
local loopActive = true
local miningActive = false

--// Rock tiers + toggle states
local ROCK_TIERS = {
    VolcanicBoulder = {count = 0, rocks = {}, highlightColor = Color3.fromRGB(255,140,0), enabled = true},
    PrismaticGem    = {count = 0, rocks = {}, highlightColor = Color3.fromRGB(95,189,175), enabled = true},
    MineralRock     = {count = 0, rocks = {}, highlightColor = Color3.fromRGB(213,115,61), enabled = true},
    NormalRock      = {count = 0, rocks = {}, highlightColor = Color3.fromRGB(163,162,165), enabled = true},
}

--// Current mining target
local CurrentTarget = nil

------------------------------------------------------------
-- ISLAND DETECTION
------------------------------------------------------------
local function detectIsland()
    local islandsFolder = Workspace:FindFirstChild("Islands")
    if not islandsFolder then
        CurrentIsland.Value = "Unknown"
        return nil
    end
    local currentParent = char and char.Parent
    while currentParent and currentParent ~= islandsFolder and currentParent ~= Workspace do
        if currentParent.Parent == islandsFolder then
            CurrentIsland.Value = currentParent.Name
            return currentParent
        end
        currentParent = currentParent.Parent
    end
    CurrentIsland.Value = "Unknown"
    return nil
end

------------------------------------------------------------
-- ROCK CLASSIFICATION
------------------------------------------------------------
local function classifyRock(model)
    local parts = model:GetDescendants()
    local primaryParts = {}
    local rocksPart
    for _, p in ipairs(parts) do
        if p:IsA("BasePart") then
            if p.Name == "Primary" then
                table.insert(primaryParts, p)
            elseif p.Name == "Rocks" then
                rocksPart = p
            elseif p.Name == "Rock" then
                return "VolcanicBoulder", {p}
            elseif tostring(p.Name):find("Rocks 2") then
                return "NormalRock", {p}
            end
        end
    end

    if #primaryParts == 5 and rocksPart then
        return "MineralRock", parts
    elseif #primaryParts == 7 and rocksPart then
        return "PrismaticGem", parts
    end
    return nil, {}
end

------------------------------------------------------------
-- REFRESH ROCKS
------------------------------------------------------------
local function refreshRocks()
    local island = detectIsland()
    if not island then return end

    for _, tier in pairs(ROCK_TIERS) do
        tier.count = 0
        tier.rocks = {}
    end

    for _, model in ipairs(island:GetChildren()) do
        if model:IsA("Model") and model.Name:sub(1,1) == "{" then
            local rockType, rockParts = classifyRock(model)
            if rockType and ROCK_TIERS[rockType] then
                ROCK_TIERS[rockType].count += 1
                table.insert(ROCK_TIERS[rockType].rocks, {model=model, parts=rockParts})
            end
        end
    end
end

------------------------------------------------------------
-- TARGET SELECTION (honors tier toggles)
------------------------------------------------------------
local function grabBestRock()
    refreshRocks()
    local priority = {"VolcanicBoulder","PrismaticGem","MineralRock","NormalRock"}
    for _, tierName in ipairs(priority) do
        local tier = ROCK_TIERS[tierName]
        if tier.enabled and tier.count > 0 and #tier.rocks > 0 then
            local rock = tier.rocks[1]
            rock.tier = tierName
            return rock
        end
    end
    return nil
end

------------------------------------------------------------
-- TELEPORT + CLICK
------------------------------------------------------------
local function tpNear(part)
    if not miningActive or not part then return end

    part.CollisionGroupId = 1
    local direction = (hrp.Position - part.Position)
    if direction.Magnitude == 0 then
        direction = Vector3.new(0,3,-2)
    end
    local offset = direction.Unit * 5
    hrp.CFrame = CFrame.new(part.Position + offset, part.Position)
    Camera.CameraType = Enum.CameraType.Custom
    Camera.CFrame = CFrame.new(hrp.Position + Vector3.new(0,2,0), part.Position)
end

local function leftClickPart(part)
    if not miningActive or not part or not part.Parent then return end
    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
    if not onScreen then
        hrp.CFrame = CFrame.new(hrp.Position, part.Position)
        Camera.CFrame = CFrame.new(Camera.CFrame.Position, part.Position)
        task.wait(0.05)
    end
    screenPos = Camera:WorldToViewportPoint(part.Position)
    VirtualInputManager:SendMouseButtonEvent(screenPos.X, screenPos.Y, 0, true, game, 0)
    task.wait(0.1)
    VirtualInputManager:SendMouseButtonEvent(screenPos.X, screenPos.Y, 0, false, game, 0)
end

------------------------------------------------------------
-- MINING LOOP
------------------------------------------------------------
task.spawn(function()
    while true do
        if miningActive then
            if not CurrentTarget or not (CurrentTarget.model and CurrentTarget.model.Parent) then
                CurrentTarget = grabBestRock()
            end

            if CurrentTarget and CurrentTarget.model and CurrentTarget.model.Parent then
                local part = CurrentTarget.parts[1]
                if part then
                    tpNear(part)
                    task.wait(1)
                    leftClickPart(part)

                    local elapsed = 0
                    while CurrentTarget.model and CurrentTarget.model.Parent and miningActive do
                        task.wait(0.2)
                        elapsed += 0.2
                        if elapsed >= 150 then
                            CurrentTarget = nil
                            break
                        end
                    end
                end
            end
        end
        task.wait(0.5)
    end
end)

------------------------------------------------------------
-- FOLDER DELETION UTILITY
------------------------------------------------------------
local function deleteFolderInIsland(folderName)
    local island = detectIsland()
    if not island then
        warn("[Rocks] No island detected.")
        return
    end

    local foundFolders = {}
    local function findFolders(parent)
        for _, child in ipairs(parent:GetChildren()) do
            if child:IsA("Folder") and child.Name == folderName then
                table.insert(foundFolders, child)
            end
            findFolders(child)
        end
    end

    findFolders(island)

    for _, folder in ipairs(foundFolders) do
        for _, obj in ipairs(folder:GetDescendants()) do
            obj:Destroy()
        end
        folder:Destroy()
        print("[Rocks] Destroyed folder:", folder:GetFullName())
    end
end

------------------------------------------------------------
-- AUTO REFRESH LOOP
------------------------------------------------------------
task.spawn(function()
    while true do
        if loopActive and not miningActive then
            refreshRocks()
        end
        task.wait(1)
    end
end)

------------------------------------------------------------
-- CHARACTER HANDLING
------------------------------------------------------------
LocalPlayer.CharacterAdded:Connect(function(newChar)
    char = newChar
    hrp = newChar:WaitForChild("HumanoidRootPart")
    detectIsland()
end)

------------------------------------------------------------
-- PUBLIC API
------------------------------------------------------------
local RockModule = {}
RockModule.Tiers = ROCK_TIERS

RockModule.GetIslandName = function() return CurrentIsland.Value end
RockModule.Refresh = refreshRocks

RockModule.ToggleLoop = function(state)
    loopActive = state == nil and not loopActive or state
    return loopActive
end

RockModule.ToggleMining = function(state)
    miningActive = state == nil and not miningActive or state
    return miningActive
end

-- Toggle specific tier by name
RockModule.ToggleTier = function(tierName, state)
    local tier = ROCK_TIERS[tierName]
    if not tier then
        warn("[Rocks] Invalid tier:", tierName)
        return
    end
    tier.enabled = state == nil and not tier.enabled or state
    print(("[Rocks] %s toggled %s"):format(tierName, tostring(tier.enabled)))
end

RockModule.IsTierEnabled = function(tierName)
    return ROCK_TIERS[tierName] and ROCK_TIERS[tierName].enabled or false
end

RockModule.CurrentTarget = function()
    return CurrentTarget
end

RockModule.DeleteLava = function()
    deleteFolderInIsland("LavaParts")
end

RockModule.DeleteTrees = function()
    deleteFolderInIsland("Trees")
end

return RockModule
