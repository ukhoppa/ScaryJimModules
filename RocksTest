-- Rocks.lua
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

-- Island name tracker
local CurrentIsland = Instance.new("StringValue")
CurrentIsland.Name = "CurrentIsland"
CurrentIsland.Value = "Unknown"
CurrentIsland.Parent = LocalPlayer

-- Rock counts & storage
local Tiers = {
    NormalRock = {count = 0, rocks = {}},
    MineralRock = {count = 0, rocks = {}},
    MineralGem = {count = 0, rocks = {}},
    PrismaticGem = {count = 0, rocks = {}},
    VolcanicBoulder = {count = 0, rocks = {}}
}

-- Helper: detect current island dynamically
local function detectIsland()
    local islandsFolder = Workspace:FindFirstChild("Islands")
    if not islandsFolder then return nil end

    local parent = char and char.Parent
    while parent and parent ~= islandsFolder and parent ~= workspace do
        if parent.Parent == islandsFolder then
            CurrentIsland.Value = parent.Name
            return parent
        end
        parent = parent.Parent
    end
    CurrentIsland.Value = "Unknown"
    return nil
end

-- Helper: classify rock by its parts & color
local function classifyRock(model)
    local parts = model:GetDescendants()
    -- Collect only BaseParts
    local baseParts = {}
    for _, p in ipairs(parts) do
        if p:IsA("BasePart") then
            table.insert(baseParts, p)
        end
    end

    -- 1. Normal Rock
    if #baseParts == 1 and baseParts[1].Name:find("Rocks 2") then
        return "NormalRock", baseParts[1].Color

    -- 2. Mineral Rock
    elseif #baseParts == 6 then
        local primaryParts = {}
        local rocksPart
        for _, p in ipairs(baseParts) do
            if p.Name == "Primary" then
                table.insert(primaryParts, p)
            elseif p.Name == "Rocks" then
                rocksPart = p
            end
        end
        if #primaryParts == 5 and rocksPart then
            return "MineralRock", primaryParts[1].Color
        end

    -- 3. Mineral Gem
    elseif #baseParts == 8 then
        local primaryParts = {}
        local rocksPart
        for _, p in ipairs(baseParts) do
            if p.Name == "Primary" then
                table.insert(primaryParts, p)
            elseif p.Name == "Rocks" then
                rocksPart = p
            end
        end
        if #primaryParts == 7 and rocksPart then
            -- Check for pointlight color
            local lightColor
            if rocksPart:FindFirstChild("Attachment") and rocksPart.Attachment:FindFirstChild("Primary") then
                lightColor = rocksPart.Attachment.Primary.Color
            else
                lightColor = primaryParts[1].Color
            end
            return "MineralGem", lightColor
        end

    -- 4. Prismatic Gem
    elseif #baseParts == 8 then
        local primaryParts = {}
        local rocksPart
        for _, p in ipairs(baseParts) do
            if p.Name == "Primary" then
                table.insert(primaryParts, p)
            elseif p.Name == "Rocks" then
                rocksPart = p
            end
        end
        if #primaryParts == 7 and rocksPart then
            -- Look for specific color alternation
            local color1 = Color3.fromRGB(112, 189, 95)
            local color2 = Color3.fromRGB(95, 189, 175)
            local found
            for _, p in ipairs(primaryParts) do
                if (p.Color - color1).Magnitude < 0.01 or (p.Color - color2).Magnitude < 0.01 then
                    found = p.Color
                    break
                end
            end
            return "PrismaticGem", found or primaryParts[1].Color
        end

    -- 5. Volcanic Boulder
    elseif #baseParts == 1 and baseParts[1].Name == "Rock" then
        local c = baseParts[1].Color
        -- check for deep orange or 255,140,0
        local orangeColor = Color3.fromRGB(255, 140, 0)
        return "VolcanicBoulder", (c - orangeColor).Magnitude < 0.05 and orangeColor or c
    end

    return nil, nil
end

-- Refresh rocks & counts
local function refreshRocks()
    local island = detectIsland()
    if not island then
        for _, tier in pairs(Tiers) do
            tier.count = 0
            tier.rocks = {}
        end
        return
    end

    -- Reset counts
    for _, tier in pairs(Tiers) do
        tier.count = 0
        tier.rocks = {}
    end

    for _, model in ipairs(island:GetChildren()) do
        if model:IsA("Model") and model.Name:sub(1,1) == "{" then
            local rockType, color = classifyRock(model)
            if rockType then
                table.insert(Tiers[rockType].rocks, {model = model, color = color})
                Tiers[rockType].count += 1
            end
        end
    end
end

-- Auto-update loop
task.spawn(function()
    while true do
        refreshRocks()
        task.wait(1)
    end
end)

-- Public API
local RockModule = {}
RockModule.GetIslandName = function()
    return CurrentIsland.Value
end
RockModule.Tiers = Tiers
RockModule.Refresh = refreshRocks

return RockModule
