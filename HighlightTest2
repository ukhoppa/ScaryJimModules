local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local LocalPlayer = Players.LocalPlayer
local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")
local Camera = Workspace.CurrentCamera

-- Island reference
local CurrentIsland = Instance.new("StringValue")
CurrentIsland.Name = "CurrentIsland"
CurrentIsland.Value = "Unknown"
CurrentIsland.Parent = LocalPlayer

-- Loop toggles
local loopActive = true
local loopMining = false

-- Rock tiers table
local ROCK_TIERS = {
    VolcanicBoulder = {count = 0, rocks = {}},
    PrismaticGem = {count = 0, rocks = {}},
    MineralGem = {count = 0, rocks = {}},
    MineralRock = {count = 0, rocks = {}},
    NormalRock = {count = 0, rocks = {}},
}

-- Utility: detect current island folder
local function detectIsland()
    local islandsFolder = Workspace:FindFirstChild("Islands")
    if not islandsFolder then
        CurrentIsland.Value = "Unknown"
        return nil
    end

    local currentParent = char and char.Parent
    while currentParent and currentParent ~= islandsFolder and currentParent ~= workspace do
        if currentParent.Parent == islandsFolder then
            CurrentIsland.Value = currentParent.Name
            return currentParent
        end
        currentParent = currentParent.Parent
    end

    CurrentIsland.Value = "Unknown"
    return nil
end

-- Utility: classify rocks
local function classifyRock(model)
    local parts = model:GetDescendants()

    if model:FindFirstChild("Rock") then
        return "VolcanicBoulder", {model.Rock}
    end

    for _, part in ipairs(parts) do
        if part:IsA("BasePart") and tostring(part.Name):find("Rocks 2") then
            return "NormalRock", {part}
        end
    end

    local primaryParts = {}
    local rocksPart
    for _, p in ipairs(parts) do
        if p:IsA("BasePart") then
            if p.Name == "Primary" then
                table.insert(primaryParts, p)
            elseif p.Name == "Rocks" then
                rocksPart = p
            end
        end
    end

    if #primaryParts == 5 and rocksPart then
        return "MineralRock", parts
    end

    if #primaryParts == 7 and rocksPart then
        return "MineralGem", parts
    end

    if #primaryParts == 7 and rocksPart then
        return "PrismaticGem", parts
    end

    return nil, {}
end

-- Refresh rocks
local function refreshRocks()
    local island = detectIsland()
    if not island then return end

    -- Reset counts
    for _, tier in pairs(ROCK_TIERS) do
        tier.count = 0
        tier.rocks = {}
    end

    for _, model in ipairs(island:GetChildren()) do
        if model:IsA("Model") and model.Name:sub(1,1) == "{" then
            local rockType, rockParts = classifyRock(model)
            if rockType then
                ROCK_TIERS[rockType].count += 1
                table.insert(ROCK_TIERS[rockType].rocks, {model=model, parts=rockParts})
            end
        end
    end
end

-- Continuous update loop
task.spawn(function()
    while true do
        if loopActive then
            refreshRocks()
        end
        task.wait(1)
    end
end)

-- Update character references on respawn
LocalPlayer.CharacterAdded:Connect(function(newChar)
    char = newChar
    hrp = newChar:WaitForChild("HumanoidRootPart")
    detectIsland()
end)

--// Mining Loop functions

-- Get target rock (first in highest-priority order)
local function getTargetRock()
    local priority = {"VolcanicBoulder","PrismaticGem","MineralGem","MineralRock","NormalRock"}
    for _, tier in ipairs(priority) do
        if ROCK_TIERS[tier] and #ROCK_TIERS[tier].rocks > 0 then
            return ROCK_TIERS[tier].rocks[1].parts[1], tier
        end
    end
    return nil, nil
end

-- Teleport near rock
local function tpNear(part)
    if not part or not part.Parent then return end
    local direction = (hrp.Position - part.Position)
    if direction.Magnitude == 0 then direction = Vector3.new(0,3,-2) end
    local offset = direction.Unit * 5
    hrp.CFrame = CFrame.new(part.Position + offset, part.Position)
    Camera.CameraType = Enum.CameraType.Custom
    Camera.CFrame = CFrame.new(hrp.Position + Vector3.new(0,2,0), part.Position)
end

-- Left click rock
local function leftClickPart(part)
    if not part or not part.Parent then return end
    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
    if not onScreen then
        tpNear(part)
        screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
    end
    if onScreen then
        VirtualInputManager:SendMouseButtonEvent(screenPos.X, screenPos.Y, 0, true, game, 0)
        task.wait(0.1)
        VirtualInputManager:SendMouseButtonEvent(screenPos.X, screenPos.Y, 0, false, game, 0)
    end
end

-- Mining loop
task.spawn(function()
    while true do
        if loopMining then
            local targetPart, tier = getTargetRock()
            if targetPart and targetPart.Parent then
                tpNear(targetPart)
                Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetPart.Position)
                task.wait(1) -- wait before clicking
                leftClickPart(targetPart)
            end
        end
        task.wait(0.5)
    end
end)

-- Public API
local RockModule = {}
RockModule.Tiers = ROCK_TIERS
RockModule.GetIslandName = function() return CurrentIsland.Value end
RockModule.Refresh = refreshRocks
RockModule.ToggleLoop = function(state)
    if state ~= nil then
        loopActive = state
    else
        loopActive = not loopActive
    end
    return loopActive
end
RockModule.ToggleMining = function(state)
    if state ~= nil then
        loopMining = state
    else
        loopMining = not loopMining
    end
    return loopMining
end

return RockModule
