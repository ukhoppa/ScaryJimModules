-- RockModule.lua
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local LocalPlayer = Players.LocalPlayer
local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")
local Camera = Workspace.CurrentCamera

-- Island reference
local IslandNameValue = Instance.new("StringValue")
IslandNameValue.Name = "CurrentIsland"
IslandNameValue.Value = "Unknown"
IslandNameValue.Parent = LocalPlayer

-- Loop toggle
local loopActive = false

-- Config: Tiers (easy to extend)
local ROCK_TIERS = {
    [1] = {colors = {Color3.fromRGB(95,189,175)}, rocks = {}},
    [2] = {colors = {Color3.fromRGB(213,115,61)}, rocks = {}},
    [3] = {colors = {Color3.fromRGB(0,170,255)}, rocks = {}}, -- default tier
}

-- Dynamic island detection
local function detectIsland()
    local islandsFolder = Workspace:FindFirstChild("Islands")
    if not islandsFolder then 
        IslandNameValue.Value = "Unknown"
        return nil
    end

    local currentIsland = char and char.Parent
    while currentIsland and currentIsland ~= islandsFolder and currentIsland ~= workspace do
        if currentIsland.Parent == islandsFolder then
            IslandNameValue.Value = currentIsland.Name
            return currentIsland
        end
        currentIsland = currentIsland.Parent
    end

    IslandNameValue.Value = "Unknown"
    return nil
end

-- Get all rock parts
local function getRockParts(model)
    local parts = {}
    if model:FindFirstChild("Rock") then table.insert(parts, model.Rock) end
    if model:FindFirstChild("Rocks") then table.insert(parts, model.Rocks) end
    for _, desc in ipairs(model:GetDescendants()) do
        if desc:IsA("BasePart") and tostring(desc.Name):find("Rocks 2") then
            table.insert(parts, desc)
        end
    end
    return parts
end

-- Determine rock tier
local function getRockTier(lightColor)
    for tier, info in pairs(ROCK_TIERS) do
        for _, c in ipairs(info.colors) do
            local tol = 0.01
            if math.abs(c.R - lightColor.R) < tol and math.abs(c.G - lightColor.G) < tol and math.abs(c.B - lightColor.B) < tol then
                return tier
            end
        end
    end
    return 3
end

-- Highlight rocks
local function highlightRock(model, tier)
    if not model or model:FindFirstChild("RockHighlight") then return end
    local hl = Instance.new("Highlight")
    hl.Name = "RockHighlight"
    hl.Adornee = model
    hl.FillColor = ROCK_TIERS[tier].colors[1] or Color3.fromRGB(150,150,150)
    hl.FillTransparency = 0.6
    hl.OutlineColor = Color3.fromRGB(255,255,255)
    hl.OutlineTransparency = 0
    hl.Parent = Workspace
end

-- Refresh rocks and counts dynamically
local function refreshRocks()
    local island = detectIsland()
    if not island then return end

    for tier, info in pairs(ROCK_TIERS) do
        info.rocks = {}
    end

    for _, model in ipairs(island:GetChildren()) do
        if model.Name:sub(1,1) == "{" then
            local parts = getRockParts(model)
            if #parts == 0 then continue end

            local light = model:FindFirstChildWhichIsA("PointLight", true)
            local tier = 3
            if light then tier = getRockTier(light.Color) end

            table.insert(ROCK_TIERS[tier].rocks, model)
            highlightRock(model, tier)
        end
    end
end

-- Move player near rock
local function tpNear(part)
    if not part then return end
    local dir = (hrp.Position - part.Position)
    if dir.Magnitude == 0 then dir = Vector3.new(0,3,-2) end
    hrp.CFrame = CFrame.new(part.Position + dir.Unit*5, part.Position)
    Camera.CameraType = Enum.CameraType.Custom
    Camera.CFrame = CFrame.new(hrp.Position + Vector3.new(0,2,0), part.Position)
end

-- Left click rock
local function clickRock(part)
    if not part or not part.Parent then return end
    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
    if not onScreen then
        hrp.CFrame = CFrame.new(hrp.Position, part.Position)
        Camera.CameraType = Enum.CameraType.Custom
        Camera.CFrame = CFrame.new(Camera.CFrame.Position, part.Position)
        task.wait(0.05)
    end
    screenPos = Camera:WorldToViewportPoint(part.Position)
    VirtualInputManager:SendMouseButtonEvent(screenPos.X, screenPos.Y, 0, true, game, 0)
    task.wait(0.1)
    VirtualInputManager:SendMouseButtonEvent(screenPos.X, screenPos.Y, 0, false, game, 0)
end

-- Continuous mining loop
task.spawn(function()
    while true do
        if loopActive then
            local island = detectIsland()
            if island then
                refreshRocks()
                for tier = 1, #ROCK_TIERS do
                    for _, rock in ipairs(ROCK_TIERS[tier].rocks) do
                        if not loopActive then break end
                        local part = rock.PrimaryPart or rock:FindFirstChild("Rock")
                        if part and part.Parent then
                            tpNear(part)
                            task.wait(0.2)
                            clickRock(part)

                            local elapsed = 0
                            while part.Parent and loopActive do
                                task.wait(0.2)
                                elapsed += 0.2
                                if elapsed >= 15 then break end
                            end
                            refreshRocks()
                        end
                    end
                end
            end
        end
        task.wait(0.5)
    end
end)

-- Refresh on respawn
LocalPlayer.CharacterAdded:Connect(function(newChar)
    char = newChar
    hrp = char:WaitForChild("HumanoidRootPart")
    detectIsland()
end)

-- Public API
local RockModule = {}
RockModule.Tiers = ROCK_TIERS
RockModule.IslandName = IslandNameValue

function RockModule.ToggleLoop()
    loopActive = not loopActive
    return loopActive
end

function RockModule.Refresh()
    refreshRocks()
end

return RockModule
