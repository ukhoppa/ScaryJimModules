-- RockModule.lua
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

-- Loop toggle
local loopActive = false

-- Tiers configuration
local ROCK_TIERS = {
    [1] = {colors = {Color3.fromRGB(95,189,175), Color3.fromRGB(189,95,175), Color3.fromRGB(255,255,0), Color3.fromRGB(0,255,0)}, rocks = {}, count = 0},
    [2] = {colors = {Color3.fromRGB(213,115,61)}, rocks = {}, count = 0},
    [3] = {colors = {}, rocks = {}, count = 0}, -- default
}

-- Highlight storage
local rockHighlights = {}

-- Detect current island dynamically
local function detectIsland()
    local islandsFolder = Workspace:FindFirstChild("Islands")
    if not islandsFolder then return nil, "Unknown" end

    local current = char and char.Parent
    while current and current ~= islandsFolder and current ~= workspace do
        if current.Parent == islandsFolder then
            return current, current.Name
        end
        current = current.Parent
    end
    return nil, "Unknown"
end

-- Get rock parts from a model
local function getRockParts(model)
    local parts = {}
    if model:FindFirstChild("Rock") then table.insert(parts, model.Rock) end
    if model:FindFirstChild("Rocks") then table.insert(parts, model.Rocks) end
    for _, desc in ipairs(model:GetDescendants()) do
        if desc:IsA("BasePart") and tostring(desc.Name):find("Rocks 2") then
            table.insert(parts, desc)
        end
    end
    return parts
end

-- Determine tier by PointLight color
local function getRockTier(lightColor)
    for tier, info in pairs(ROCK_TIERS) do
        for _, c in ipairs(info.colors) do
            local tol = 0.01
            if math.abs(c.R - lightColor.R) < tol and math.abs(c.G - lightColor.G) < tol and math.abs(c.B - lightColor.B) < tol then
                return tier, c
            end
        end
    end
    return 3, nil
end

-- Highlight a rock
local function handleRock(model, color)
    if model:FindFirstChildOfClass("Humanoid") then return end
    if not color then color = Color3.fromRGB(0,170,255) end

    if not rockHighlights[model] then
        local hl = Instance.new("Highlight")
        hl.Name = "RockHighlight"
        hl.Adornee = model
        hl.FillColor = color
        hl.FillTransparency = 0.6
        hl.OutlineColor = Color3.fromRGB(255,255,255)
        hl.OutlineTransparency = 0
        hl.Parent = Workspace
        rockHighlights[model] = hl
    else
        rockHighlights[model].FillColor = color
    end
end

-- Refresh rocks & counts dynamically
local function refreshRocks()
    local island, islandName = detectIsland()
    if not island then return end

    -- Reset tiers
    for _, info in pairs(ROCK_TIERS) do
        info.rocks = {}
        info.count = 0
    end

    for _, model in ipairs(island:GetChildren()) do
        if model.Name:sub(1,1) == "{" then
            local parts = getRockParts(model)
            if #parts == 0 then continue end

            local tier, color = 3, nil
            local light = model:FindFirstChildWhichIsA("PointLight", true)
            if light then
                tier, color = getRockTier(light.Color)
            end

            table.insert(ROCK_TIERS[tier].rocks, {model = model, parts = parts})
            ROCK_TIERS[tier].count += 1

            handleRock(model, color)
        end
    end

    return islandName
end

-- Teleport near a rock
local function tpNear(part)
    if not part or not hrp then return end
    local offset = Vector3.new(0,3,0)
    hrp.CFrame = CFrame.new(part.Position + offset, part.Position)
end

-- Mining loop
task.spawn(function()
    while true do
        if loopActive then
            local _ = refreshRocks()
            for tier = 1,3 do
                for _, rockData in ipairs(ROCK_TIERS[tier].rocks) do
                    if not loopActive then break end
                    local part = rockData.parts[1]
                    if part and part.Parent then
                        tpNear(part)
                        task.wait(0.2)
                        -- simulate click (replace with VirtualInput if needed)
                        -- leftClickPart(part)
                        task.wait(0.5)
                    end
                end
            end
        end
        task.wait(1)
    end
end)

-- Update character on respawn
LocalPlayer.CharacterAdded:Connect(function(newChar)
    char = newChar
    hrp = char:WaitForChild("HumanoidRootPart")
end)

-- Public API
local RockModule = {}
RockModule.Tiers = ROCK_TIERS
RockModule.ToggleLoop = function()
    loopActive = not loopActive
    return loopActive
end
RockModule.Refresh = refreshRocks

return RockModule
