Rayfield:Notify({Title = "ðŸŒ‹ Rocks", Content = "Rock module loaded", Duration = 5})
-- RockModule.lua
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

-- Island reference
local IslandNameValue = Instance.new("StringValue")
IslandNameValue.Name = "CurrentIsland"
IslandNameValue.Value = "Unknown"
IslandNameValue.Parent = LocalPlayer

-- Loop toggle
local loopActive = false

-- Config: Tiers
local ROCK_TIERS = {
    [1] = {colors = {Color3.fromRGB(95,189,175)}, count = 0, rocks = {}},
    [2] = {colors = {Color3.fromRGB(213,115,61)}, count = 0, rocks = {}},
    [3] = {colors = {}, count = 0, rocks = {}}, -- default tier
}

-- Helper: Find island folder
local function detectIsland()
    local islandsFolder = Workspace:FindFirstChild("Islands")
    if not islandsFolder then return nil end

    local currentIsland = char and char.Parent
    while currentIsland and currentIsland ~= islandsFolder and currentIsland ~= workspace do
        if currentIsland.Parent == islandsFolder then
            IslandNameValue.Value = currentIsland.Name
            return currentIsland
        end
        currentIsland = currentIsland.Parent
    end

    IslandNameValue.Value = "Unknown"
    return nil
end

-- Helper: Get all rock parts in model
local function getRockParts(model)
    local parts = {}
    if model:FindFirstChild("Rock") then table.insert(parts, model.Rock) end
    if model:FindFirstChild("Rocks") then table.insert(parts, model.Rocks) end
    for _, desc in ipairs(model:GetDescendants()) do
        if desc:IsA("BasePart") and tostring(desc.Name):find("Rocks 2") then
            table.insert(parts, desc)
        end
    end
    return parts
end

-- Helper: Determine rock tier based on color
local function getRockTier(lightColor)
    for tier, info in pairs(ROCK_TIERS) do
        for _, c in ipairs(info.colors) do
            local tol = 0.01
            if math.abs(c.R - lightColor.R) < tol and
               math.abs(c.G - lightColor.G) < tol and
               math.abs(c.B - lightColor.B) < tol then
                return tier
            end
        end
    end
    return 3 -- default tier
end

-- Refresh rocks & counts
local function refreshRocks()
    local island = detectIsland()
    if not island then return end

    -- Reset
    for tier, info in pairs(ROCK_TIERS) do
        info.count = 0
        info.rocks = {}
    end

    for _, model in ipairs(island:GetChildren()) do
        if model.Name:sub(1,1) == "{" then
            local parts = getRockParts(model)
            if #parts == 0 then continue end

            -- Determine tier by PointLight color
            local light = model:FindFirstChildWhichIsA("PointLight", true)
            local tier = 3
            if light then tier = getRockTier(light.Color) end

            -- Save & count
            table.insert(ROCK_TIERS[tier].rocks, model)
            ROCK_TIERS[tier].count += 1

            -- Highlight
            if not model:FindFirstChild("RockHighlight") then
                local hl = Instance.new("Highlight")
                hl.Name = "RockHighlight"
                hl.Adornee = model
                hl.FillColor = ROCK_TIERS[tier].colors[1] or Color3.fromRGB(150,150,150)
                hl.FillTransparency = 0.6
                hl.OutlineColor = Color3.fromRGB(255,255,255)
                hl.OutlineTransparency = 0
                hl.Parent = Workspace
            end
        end
    end
end

-- Mining loop
task.spawn(function()
    while true do
        if loopActive then
            refreshRocks()

            -- Mine loop (simple)
            for tier = 1,3 do
                for _, rock in ipairs(ROCK_TIERS[tier].rocks) do
                    if not loopActive then break end
                    if rock.PrimaryPart or rock:FindFirstChild("Rock") then
                        local part = rock.PrimaryPart or rock:FindFirstChild("Rock")
                        hrp.CFrame = CFrame.new(part.Position + Vector3.new(0,3,0), part.Position)
                        task.wait(0.2)
                        -- Simulate click
                        if part:IsA("BasePart") then
                            part:Destroy() -- placeholder, replace with VirtualInput click
                        end
                        task.wait(0.5)
                    end
                end
            end
        end
        task.wait(1)
    end
end)

-- Refresh on respawn
LocalPlayer.CharacterAdded:Connect(function(newChar)
    char = newChar
    hrp = char:WaitForChild("HumanoidRootPart")
    detectIsland()
end)

-- Public API
local RockModule = {}
RockModule.Tiers = ROCK_TIERS
RockModule.IslandName = IslandNameValue

function RockModule.ToggleLoop()
    loopActive = not loopActive
    return loopActive
end

function RockModule.Refresh()
    refreshRocks()
end

return RockModule
